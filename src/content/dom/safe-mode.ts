/**
 * Safe Mode System for Ishka Extension
 * 
 * Provides graceful degradation when ChatGPT updates break selectors
 * or when the extension detects an incompatible environment.
 * 
 * Safe Mode ensures the extension never crashes ChatGPT and provides
 * clear feedback to users about temporary limitations.
 */

import { validateSelectors, type SelectorHealth } from './selectors.js';\nimport { enhancedStorageManager } from '../../utils/storage/enhanced-storage-manager.js';\nimport { logger } from '../../utils/logger.js';\n\nexport interface SafeModeState {\n  active: boolean;\n  reason: string;\n  activatedAt: Date;\n  affectedFeatures: string[];\n  criticalSelectorsDown: number;\n  totalSelectorsChecked: number;\n}\n\nexport interface SafeModeConfig {\n  // Thresholds for activation\n  maxCriticalSelectorFailures: number;\n  maxConsecutiveHealthCheckFailures: number;\n  \n  // Monitoring intervals\n  healthCheckIntervalMs: number;\n  recoveryCheckIntervalMs: number;\n  \n  // Recovery settings\n  autoRecoveryEnabled: boolean;\n  recoverySuccessThreshold: number;\n}\n\n/**\n * Safe Mode Manager - Handles graceful degradation\n */\nexport class SafeModeManager {\n  private static instance: SafeModeManager;\n  private state: SafeModeState;\n  private config: SafeModeConfig;\n  private healthCheckInterval: NodeJS.Timeout | null = null;\n  private recoveryCheckInterval: NodeJS.Timeout | null = null;\n  private consecutiveFailures = 0;\n  private listeners: ((state: SafeModeState) => void)[] = [];\n\n  private constructor() {\n    this.state = {\n      active: false,\n      reason: '',\n      activatedAt: new Date(),\n      affectedFeatures: [],\n      criticalSelectorsDown: 0,\n      totalSelectorsChecked: 0\n    };\n\n    this.config = {\n      maxCriticalSelectorFailures: 3,\n      maxConsecutiveHealthCheckFailures: 3,\n      healthCheckIntervalMs: 30000, // 30 seconds\n      recoveryCheckIntervalMs: 60000, // 1 minute\n      autoRecoveryEnabled: true,\n      recoverySuccessThreshold: 2 // 2 consecutive successful checks\n    };\n  }\n\n  static getInstance(): SafeModeManager {\n    if (!SafeModeManager.instance) {\n      SafeModeManager.instance = new SafeModeManager();\n    }\n    return SafeModeManager.instance;\n  }\n\n  /**\n   * Initialize Safe Mode monitoring\n   */\n  async initialize(): Promise<void> {\n    logger.info('[SafeMode] Initializing Safe Mode monitoring');\n    \n    // Check if Safe Mode was previously active\n    const wasActive = await enhancedStorageManager.isSafeModeActive();\n    if (wasActive) {\n      logger.warn('[SafeMode] Safe Mode was active on startup, performing health check');\n      await this.performHealthCheck();\n    }\n\n    // Start monitoring\n    this.startHealthMonitoring();\n  }\n\n  /**\n   * Activate Safe Mode with specific reason\n   */\n  async activateSafeMode(reason: string, affectedFeatures: string[] = []): Promise<void> {\n    if (this.state.active) {\n      logger.warn('[SafeMode] Safe Mode already active, updating reason');\n    }\n\n    this.state = {\n      active: true,\n      reason,\n      activatedAt: new Date(),\n      affectedFeatures,\n      criticalSelectorsDown: this.state.criticalSelectorsDown,\n      totalSelectorsChecked: this.state.totalSelectorsChecked\n    };\n\n    // Persist state\n    await enhancedStorageManager.setSafeModeActive(true, reason);\n    \n    // Log activation\n    logger.error('[SafeMode] Safe Mode ACTIVATED', {\n      reason,\n      affectedFeatures,\n      criticalSelectorsDown: this.state.criticalSelectorsDown\n    });\n\n    // Notify listeners\n    this.notifyListeners();\n\n    // Start recovery monitoring if enabled\n    if (this.config.autoRecoveryEnabled && !this.recoveryCheckInterval) {\n      this.startRecoveryMonitoring();\n    }\n\n    // Show user notification\n    this.showSafeModeNotification();\n  }\n\n  /**\n   * Deactivate Safe Mode\n   */\n  async deactivateSafeMode(): Promise<void> {\n    if (!this.state.active) {\n      return;\n    }\n\n    const previousReason = this.state.reason;\n    \n    this.state = {\n      active: false,\n      reason: '',\n      activatedAt: new Date(),\n      affectedFeatures: [],\n      criticalSelectorsDown: 0,\n      totalSelectorsChecked: 0\n    };\n\n    // Clear persistence\n    await enhancedStorageManager.setSafeModeActive(false);\n    \n    // Log deactivation\n    logger.info('[SafeMode] Safe Mode DEACTIVATED', {\n      previousReason,\n      recoveredAt: new Date()\n    });\n\n    // Stop recovery monitoring\n    if (this.recoveryCheckInterval) {\n      clearInterval(this.recoveryCheckInterval);\n      this.recoveryCheckInterval = null;\n    }\n\n    // Reset failure counter\n    this.consecutiveFailures = 0;\n\n    // Notify listeners\n    this.notifyListeners();\n\n    // Show recovery notification\n    this.showRecoveryNotification();\n  }\n\n  /**\n   * Check if Safe Mode is currently active\n   */\n  isSafeModeActive(): boolean {\n    return this.state.active;\n  }\n\n  /**\n   * Get current Safe Mode state\n   */\n  getSafeModeState(): SafeModeState {\n    return { ...this.state };\n  }\n\n  /**\n   * Check if a specific feature is affected by Safe Mode\n   */\n  isFeatureAffected(featureName: string): boolean {\n    return this.state.active && this.state.affectedFeatures.includes(featureName);\n  }\n\n  /**\n   * Add a listener for Safe Mode state changes\n   */\n  onSafeModeChange(listener: (state: SafeModeState) => void): () => void {\n    this.listeners.push(listener);\n    return () => {\n      const index = this.listeners.indexOf(listener);\n      if (index > -1) {\n        this.listeners.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * Perform health check on selectors\n   */\n  async performHealthCheck(): Promise<SelectorHealth> {\n    try {\n      const health = await validateSelectors();\n      \n      // Count critical selector failures\n      const criticalFailures = Object.values(health.critical).filter(status => !status).length;\n      const totalCritical = Object.keys(health.critical).length;\n      \n      this.state.criticalSelectorsDown = criticalFailures;\n      this.state.totalSelectorsChecked = totalCritical;\n      \n      // Check if we should activate Safe Mode\n      if (criticalFailures >= this.config.maxCriticalSelectorFailures) {\n        this.consecutiveFailures++;\n        \n        if (this.consecutiveFailures >= this.config.maxConsecutiveHealthCheckFailures) {\n          const reason = `${criticalFailures}/${totalCritical} critical selectors failed`;\n          const affectedFeatures = this.determineAffectedFeatures(health);\n          await this.activateSafeMode(reason, affectedFeatures);\n        }\n      } else {\n        // Reset failure counter on success\n        this.consecutiveFailures = 0;\n        \n        // Check if we should recover from Safe Mode\n        if (this.state.active && criticalFailures === 0) {\n          await this.deactivateSafeMode();\n        }\n      }\n      \n      return health;\n    } catch (error) {\n      logger.error('[SafeMode] Health check failed', error);\n      \n      // On health check failure, activate Safe Mode\n      await this.activateSafeMode('Health check system failure', ['all']);\n      \n      throw error;\n    }\n  }\n\n  /**\n   * Manually trigger Safe Mode (for testing or user activation)\n   */\n  async manualActivation(reason: string = 'Manual activation'): Promise<void> {\n    await this.activateSafeMode(reason, ['manual']);\n  }\n\n  /**\n   * Force recovery attempt (for testing or user action)\n   */\n  async forceRecovery(): Promise<boolean> {\n    try {\n      const health = await this.performHealthCheck();\n      const criticalFailures = Object.values(health.critical).filter(status => !status).length;\n      \n      if (criticalFailures === 0) {\n        await this.deactivateSafeMode();\n        return true;\n      }\n      \n      return false;\n    } catch (error) {\n      logger.error('[SafeMode] Force recovery failed', error);\n      return false;\n    }\n  }\n\n  /**\n   * Start health monitoring\n   */\n  private startHealthMonitoring(): void {\n    if (this.healthCheckInterval) {\n      clearInterval(this.healthCheckInterval);\n    }\n\n    this.healthCheckInterval = setInterval(async () => {\n      try {\n        await this.performHealthCheck();\n      } catch (error) {\n        logger.error('[SafeMode] Health monitoring error', error);\n      }\n    }, this.config.healthCheckIntervalMs);\n  }\n\n  /**\n   * Start recovery monitoring\n   */\n  private startRecoveryMonitoring(): void {\n    if (this.recoveryCheckInterval) {\n      clearInterval(this.recoveryCheckInterval);\n    }\n\n    let successfulRecoveryChecks = 0;\n\n    this.recoveryCheckInterval = setInterval(async () => {\n      try {\n        const health = await validateSelectors();\n        const criticalFailures = Object.values(health.critical).filter(status => !status).length;\n        \n        if (criticalFailures === 0) {\n          successfulRecoveryChecks++;\n          \n          if (successfulRecoveryChecks >= this.config.recoverySuccessThreshold) {\n            await this.deactivateSafeMode();\n          }\n        } else {\n          successfulRecoveryChecks = 0;\n        }\n      } catch (error) {\n        logger.error('[SafeMode] Recovery monitoring error', error);\n        successfulRecoveryChecks = 0;\n      }\n    }, this.config.recoveryCheckIntervalMs);\n  }\n\n  /**\n   * Determine which features are affected by selector failures\n   */\n  private determineAffectedFeatures(health: SelectorHealth): string[] {\n    const affected: string[] = [];\n    \n    // Map selector failures to feature names\n    const selectorFeatureMap: { [key: string]: string } = {\n      'injection.promptTextareaContainer': 'voice-input',\n      'injection.conversationContainer': 'floating-panel',\n      'injection.messageContainer': 'per-message-notes',\n      'injection.sidebarContainer': 'conversation-tags',\n      'content.messageText': 'export-functionality'\n    };\n    \n    for (const [selectorPath, isHealthy] of Object.entries(health.critical)) {\n      if (!isHealthy && selectorFeatureMap[selectorPath]) {\n        affected.push(selectorFeatureMap[selectorPath]);\n      }\n    }\n    \n    return affected;\n  }\n\n  /**\n   * Show Safe Mode notification to user\n   */\n  private showSafeModeNotification(): void {\n    // This will be implemented when we add the notification system\n    // For now, we'll log to console\n    console.warn('ðŸ›¡ï¸ Ishka Safe Mode Active', {\n      reason: this.state.reason,\n      affectedFeatures: this.state.affectedFeatures,\n      message: 'Some features are temporarily disabled due to ChatGPT updates. Your data is safe.'\n    });\n  }\n\n  /**\n   * Show recovery notification to user\n   */\n  private showRecoveryNotification(): void {\n    // This will be implemented when we add the notification system\n    console.info('âœ… Ishka Safe Mode Deactivated', {\n      message: 'All features have been restored and are working normally.'\n    });\n  }\n\n  /**\n   * Notify all listeners of state changes\n   */\n  private notifyListeners(): void {\n    for (const listener of this.listeners) {\n      try {\n        listener(this.state);\n      } catch (error) {\n        logger.error('[SafeMode] Listener error', error);\n      }\n    }\n  }\n\n  /**\n   * Cleanup resources\n   */\n  destroy(): void {\n    if (this.healthCheckInterval) {\n      clearInterval(this.healthCheckInterval);\n      this.healthCheckInterval = null;\n    }\n    \n    if (this.recoveryCheckInterval) {\n      clearInterval(this.recoveryCheckInterval);\n      this.recoveryCheckInterval = null;\n    }\n    \n    this.listeners = [];\n  }\n}\n\n// Export singleton instance\nexport const safeModeManager = SafeModeManager.getInstance();\n\n// Export convenience functions\nexport const isSafeModeActive = () => safeModeManager.isSafeModeActive();\nexport const getSafeModeState = () => safeModeManager.getSafeModeState();\nexport const isFeatureAffected = (feature: string) => safeModeManager.isFeatureAffected(feature);\n\n// Export for initialization\nexport const initializeSafeMode = () => safeModeManager.initialize();\n\n/**\n * Decorator for functions that should be disabled in Safe Mode\n */\nexport function safeModeGuard(featureName: string) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    const originalMethod = descriptor.value;\n    \n    descriptor.value = function (...args: any[]) {\n      if (safeModeManager.isFeatureAffected(featureName)) {\n        logger.warn(`[SafeMode] Feature ${featureName} is disabled in Safe Mode`);\n        return null;\n      }\n      \n      return originalMethod.apply(this, args);\n    };\n    \n    return descriptor;\n  };\n}\n\n/**\n * Utility function to wrap feature functions with Safe Mode protection\n */\nexport function withSafeModeProtection<T extends (...args: any[]) => any>(\n  fn: T,\n  featureName: string,\n  fallbackValue: ReturnType<T> = null\n): T {\n  return ((...args: any[]) => {\n    if (safeModeManager.isFeatureAffected(featureName)) {\n      logger.warn(`[SafeMode] Feature ${featureName} is disabled in Safe Mode`);\n      return fallbackValue;\n    }\n    \n    return fn(...args);\n  }) as T;\n}